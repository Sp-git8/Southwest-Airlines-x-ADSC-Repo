# -*- coding: utf-8 -*-
"""Copy of data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xJIHexZaHrNb7qFQ_ryyCMYvmT4-RJLP
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

"""# Data cleaning (balancing)"""

# IAH
df_IAH = pd.read_csv("/content/drive/Data/MyDrive/Southwest x ADSC/Detailed_Statistics_Departures-3.csv")
df_IAH['Origin Airport'] = 'KIAH'

df_delay_IAH = df_IAH[df_IAH['Delay Weather (Minutes)'] > 0] #set with weather delay
df_no_delays_IAH = df_IAH[df_IAH['Delay Weather (Minutes)'] == 0].sample(n=len(df_delay_IAH), random_state=42) #takes data from original file at random with length od dF ( so equal numbers of delay and no delay)
df_IAH = pd.concat([df_delay_IAH, df_no_delays_IAH])
df_IAH = df_IAH[['Date (MM/DD/YYYY)','Origin Airport','Destination Airport','Scheduled departure time','Delay Weather (Minutes)', 'Flight Number']]
#r^2 value- how much data the model covers
#the accuracy 90-100%

# HOU
df_Hobby = pd.read_csv("/content/drive/MyDrive/Data/Southwest x ADSC/Detailed_Statistics_Departures-Hobby.csv")
df_Hobby['Origin Airport'] = 'KHOU'

df_delay_Hobby = df_Hobby[df_Hobby['Delay Weather (Minutes)'] > 0]
df_no_delays_Hobby = df_Hobby[df_Hobby['Delay Weather (Minutes)'] == 0].sample(n=len(df_delay_Hobby), random_state=42)
df_Hobby = pd.concat([df_delay_Hobby, df_no_delays_Hobby])
df_Hobby = df_Hobby[['Date (MM/DD/YYYY)','Origin Airport','Destination Airport','Scheduled departure time','Delay Weather (Minutes)', 'Flight Number']]

df_IAH['datetime'] = pd.to_datetime(df_IAH['Date (MM/DD/YYYY)'] + ' ' + df_IAH['Scheduled departure time'])
df_IAH['datetime'] = df_IAH['datetime'].dt.strftime('%Y-%m-%d %H:%M:%S')

df_Hobby['datetime'] = pd.to_datetime(df_Hobby['Date (MM/DD/YYYY)'] + ' ' + df_Hobby['Scheduled departure time'])
df_Hobby['datetime'] = df_Hobby['datetime'].dt.strftime('%Y-%m-%d %H:%M:%S')

! pip install meteostat

"""# Weather data cleaning"""

from meteostat import Stations, Daily, Point, Hourly
from datetime import datetime

import warnings
warnings.filterwarnings("ignore", category=FutureWarning)

stations = Stations()

#IAH
iah = stations.region('US', 'TX').fetch()
iah_station = iah[iah['icao'] == 'KIAH'].iloc[0]
iah_location = Point(iah_station['latitude'], iah_station['longitude'], iah_station['elevation'])

start = datetime(2009, 1, 1)
end = datetime(2025, 1, 1)

data_iah = Hourly(iah_location, start, end)
weather_iah = data_iah.fetch()

weather_iah.reset_index(inplace=True)
weather_iah = weather_iah.set_index('time').resample('1T').interpolate(method='time').reset_index()
weather_iah['Origin Airport'] = 'KIAH'

weather_iah.rename(columns={
    'time': 'datetime',
    'temp': 'temperature_C',
    'dwpt': 'dew_point_C',
    'rhum': 'humidity_percent',
    'prcp': 'precipitation_mm',
    'snow': 'snowfall_mm',
    'wdir': 'wind_direction_deg',
    'wspd': 'wind_speed_kmh',
    'wpgt': 'wind_gust_kmh',
    'pres': 'pressure_hPa',
    'tsun': 'sunshine_minutes',
    'coco': 'weather_code'
}, inplace=True)

weather_iah = weather_iah.drop(columns=['dew_point_C', 'sunshine_minutes', 'weather_code'])

import warnings
warnings.filterwarnings("ignore", category=FutureWarning)

#HOU
hou = stations.region('US', 'TX').fetch()
hou_station = hou[hou['icao'] == 'KHOU'].iloc[0]

hou_location = Point(hou_station['latitude'], hou_station['longitude'], hou_station['elevation'])

start = datetime(2005, 1, 1)
end = datetime(2025, 1, 1)

data_hou = Hourly(hou_location, start, end)
weather_hou = data_hou.fetch()

weather_hou.reset_index(inplace=True)

weather_hou = weather_hou.set_index('time').resample('1T').interpolate(method='time').reset_index()


weather_hou['Origin Airport'] = 'KHOU'

weather_hou.rename(columns={
    'time': 'datetime',
    'temp': 'temperature_C',
    'dwpt': 'dew_point_C',
    'rhum': 'humidity_percent',
    'prcp': 'precipitation_mm',
    'snow': 'snowfall_mm',
    'wdir': 'wind_direction_deg',
    'wspd': 'wind_speed_kmh',
    'wpgt': 'wind_gust_kmh',
    'pres': 'pressure_hPa',
    'tsun': 'sunshine_minutes',
    'coco': 'weather_code'
}, inplace=True)


weather_hou = weather_hou.drop(columns=['dew_point_C', 'sunshine_minutes', 'weather_code'])

df_IAH['datetime'] = pd.to_datetime(df_IAH['datetime'], errors='coerce')
weather_iah['datetime'] = pd.to_datetime(weather_iah['datetime'], errors='coerce')

df_Hobby['datetime'] = pd.to_datetime(df_Hobby['datetime'], errors='coerce')
weather_hou['datetime'] = pd.to_datetime(weather_hou['datetime'], errors='coerce')

df_IAH = df_IAH.sort_values('datetime')
weather_IAH = weather_iah.sort_values('datetime')

df_HOU = df_Hobby.sort_values('datetime')
weather_HOU = weather_hou.sort_values('datetime')

# Merge flights with weather for each airport separately
merged_IAH = pd.merge_asof(
    df_IAH,
    weather_IAH,
    on='datetime',
    direction='backward',   # or 'nearest' if you want closest time
    tolerance=pd.Timedelta('1H')  # optional
)

merged_HOU = pd.merge_asof(
    df_HOU,
    weather_HOU,
    on='datetime',
    direction='backward',
    tolerance=pd.Timedelta('1H')
)

merged_IAH = merged_IAH[merged_IAH['datetime'] <= pd.to_datetime('2025-01-01')]
merged_IAH = merged_IAH[merged_IAH['datetime'].dt.year >= 2009]

merged_IAH

merged_HOU = merged_HOU[merged_HOU['datetime'] <= pd.to_datetime('2025-01-01')]

merged_HOU

df_all = pd.concat([merged_IAH, merged_HOU], ignore_index=True)

df_all

df_all['snowfall_mm'] = df_all['snowfall_mm'].fillna(0)
df_all = df_all.drop(columns=['wind_gust_kmh'])
print(df_all.isna().sum())

target_regression = 'Delay Weather (Minutes)'
target_classification = 'Delay Weather (Minutes) > 0'  # binary

# Suppose your dataframe has a 'datetime' column
df_all['hour'] = df_all['datetime'].dt.hour
df_all['day'] = df_all['datetime'].dt.day
df_all['month'] = df_all['datetime'].dt.month

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier
from sklearn.metrics import mean_squared_error, r2_score, accuracy_score
import lightgbm as lgb

features = ['temperature_C', 'humidity_percent',
            'precipitation_mm', 'snowfall_mm', 'wind_direction_deg',
            'wind_speed_kmh', 'pressure_hPa', 'hour', 'day']

df_all = df_all.sort_values('datetime')
df_all[features] = df_all[features].fillna(method='ffill').fillna(df_all[features].mean())

df_all['Delay_Flag'] = (df_all['Delay Weather (Minutes)'] > 0).astype(int)


X = df_all[features]
y_reg = df_all['Delay Weather (Minutes)']
y_clf = df_all['Delay_Flag']


X_train, X_test, y_reg_train, y_reg_test, y_clf_train, y_clf_test = train_test_split(
    X, y_reg, y_clf, test_size=0.2, random_state=42
)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

lr.fit(X_train_scaled, y_reg_train)
y_lr_pred = lr.predict(X_test_scaled)
print("Linear Regression MSE:", mean_squared_error(y_reg_test, y_lr_pred))
print("Linear Regression R2:", r2_score(y_reg_test, y_lr_pred))


rf_reg = RandomForestRegressor(n_estimators=200, random_state=42)
rf_reg.fit(X_train, y_reg_train)
y_rf_pred = rf_reg.predict(X_test)
print("Random Forest Regressor MSE:", mean_squared_error(y_reg_test, y_rf_pred))
print("Random Forest Regressor R2:", r2_score(y_reg_test, y_rf_pred))

rf_clf = RandomForestClassifier(n_estimators=200, random_state=42)
rf_clf.fit(X_train, y_clf_train)
y_clf_pred = rf_clf.predict(X_test)
print("Random Forest Classifier Accuracy:", accuracy_score(y_clf_test, y_clf_pred))

import xgboost as xgb
from xgboost import XGBRegressor, XGBClassifier
from sklearn.metrics import mean_squared_error, r2_score, accuracy_score, classification_report

xgb_reg = XGBRegressor(
    n_estimators=200,
    learning_rate=0.05,
    max_depth=6,
    subsample=0.8,
    colsample_bytree=0.8,
    random_state=42,
    verbosity=0
)

xgb_reg.fit(X_train, y_reg_train)
y_reg_pred = xgb_reg.predict(X_test)
print("XGBRegressor results")
print("MSE:", mean_squared_error(y_reg_test, y_reg_pred))
print("R2:", r2_score(y_reg_test, y_reg_pred))


xgb_clf = XGBClassifier(
    n_estimators=200,
    learning_rate=0.05,
    max_depth=6,
    subsample=0.8,
    colsample_bytree=0.8,
    random_state=42,
    use_label_encoder=False,
    verbosity=0
)

xgb_clf.fit(X_train, y_clf_train)
y_clf_pred = xgb_clf.predict(X_test)
print("\nXGBClassifier results")
print("Accuracy:", accuracy_score(y_clf_test, y_clf_pred))
print(classification_report(y_clf_test, y_clf_pred, zero_division=0))

